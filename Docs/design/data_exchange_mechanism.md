数据交换机制
Data Exchange Mechanism

Vapula类型系统与用户数据托管方案
Vapula的类型系统没有与组件关联，
所以没有面向对象组件设计的必要，
组件和功能也不能对应到面向对象设计的类和方法。
不设计基于组件的类型系统，
组件与数据类型不存在直接关系

实际的数据是无类型的。
Vapula在存储数据时也依据该原则，
没有强制约束类型。

为了能够提高开发人员在强类型运行时中高效操作数据。
Vapula使用Pointer提供特定运行时的安全内存操作指令。
基于扩展的类型描述和自动编译器，
Vapula可以自动进行数据重整，实现有结构的数据传输。
这是高级特性，需要开发人员专门开发。
任意两个组件功能之间传输数据都需要进行数据重整脚本的编写。
当然，开发人员也可以自行重整内存。

Vapula的类型系统仅用于约束：
在多个节点间传递的数据与数据结构信息。
此处节点指组件功能（不确定运行时下的不确定组件的不确定功能）、调用方、非Vapula相关数据源或数据受体

目前没有为 数据结构 设计统一的 描述用途 数据类型。

为了在多种运行时环境之间共享这些数据，Vapula约束了数据传递的原则。
1.	所有数据在传输时，同类数据直接复制。
2.	序列化时机
3.	序列化机制（值=>Base64字符串，文本=>字符串，裸数据根据是否需要结构化信息：是=>JSON字符串；否=>Base64字符串）
4.	反序列化使用逆过程

Vapula使用可扩展类型接口提供用户自定义类型的支持。
用户有这样的需求：
1.	用户使用特定运行时环境，该运行时环境自身具备类型系统的约束。用户在该类型系统约束下自定义类型。
2.	用户在某运行时环境下定义的类型在其他运行时环境可用。

为了设计这样的通用类型系统约束，Vapula通过特定的序列化接口进行中间转换。
所有的用户类型在进行传递时

Vapula通过数据集（Dataset）和记录（Record）实现用户数据托管。
数据集是记录的有序集合，提供记录的检索和动态增减功能。
数据集的生成有两种途径，一种是在组件操作中生成，一种是用户自行生成。
当组件加载时，会为每个方法构造原型数据集。
当用户调用组件方法时，调用器会复制原型数据集，并托管在虚拟栈。
用户也可以自行编写符合规范的XML，构造用户自定义信封。

Vapula通过堆（和内存池）管理数据集中托管的记录的数据。

记录是参数的数据实体，由数据集托管。
每个记录包含数据类型、访问模式、数据尺寸等信息。
Vapula支持3种数据类型。
Vapula的访问模式有3种：仅输入、仅输出、输入或输出。

（表格）

通过这些基本类型，Vapula理论上可以操作任意数据类型。

受制于不同语言、运行时对数据类型的定义的差别。
Vapula做出以下限制：
除Object和String外，其他类型为基值类型
String是Object的一种特殊细分，作为非基值类型与object没有本质区别，
只是可以使用一些更具体的API进行操作。
基值类型变量的数据作为一个数组存储
非基值类型变量的数据只能存储为一个独立个体，不能存储为数组

Vapula会识别写入和读取的类型是否是基值类型
根据判定结果，Vapula确定是否可以调用访问方法

同时，Vapula不关心数据的具体存储类型
对于基值类型，Vapula提供一些语法糖（模板函数），
可进行快速单值读取和写入，目的仅仅是简化操作
再次重申，Vapula不检测访问基值类型时使用的数据类型是否匹配

写入字符串时会自动复制并存储副本

投递操作：
投递是Vapula定义的一种行为，表示参数从一个变量传递到另一个变量，可以通过Deliver方法调用。
在Variable之间进行Deliver涉及潜在的内存复制，
不复制内存仅会传递数据的访问权，通过复制操作可以复制数据的拥有权。
Vapula不关心类型的实际数据构成，所以类型之间虽然执行了数据传递，
但是不能保证这个操作是有实际意义的。

为了提供更多灵活性，
Variable还提供地址操作、序列化操作
地址操作包括内存取地址和地址还原。
序列化操作提供内存压缩编码支持。
通过内存压缩编码可以将任意数据块压缩编码成base64，方便数据传输

地址操作通过Read、Write即可实现


一般获得Envelope后：
设置值：
Variable* var = env -> GetVariable(1);
var -> Write<int>(12);
var -> Write (data, 1024, true);
var -> Write(str, true); //非基值类型可用
