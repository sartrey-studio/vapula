driver mechanism
驱动机制

一个应用程序由唯一的主循环和众多被调功能组成。
最简单的应用程序可能仅包含一个顺序执行功能的主循环。
复杂的应用程序，其主循环可能包含动态的、交错的功能调用。

良好的软件设计应当能够将主循环从应用程序中解耦，
使开发人员能够单独开发、测试功能。
  
主体负责装载、卸载、调用组件功能，对外提供主要用户界面。
组件对一类组织在一起的功能负责。

组件逻辑上包含多个功能，内部的实现不受到Vapula约束。
但是对外必须提供所有的功能的调用接口。
功能的调用状态、输入输出参数以及其他共享信息（共享给组件和调用方）托管在Vapula提供的私有栈里。

驱动机制
Driver是Vapula的驱动机制的核心所在
驱动开发者可以开发一个具有GetDriverInstance的C接口的DLL
然后实现Library和Invoker基类
Vapula的驱动机制目标是实现所有支持的环境之间两两可以互相调用
Vapula认为所有运行环境加载该环境下的组件是最方便的。
所以驱动开发者需要在驱动DLL中仅开发加载特定运行时的托管过程以及调用Vapula核心Bridge（C++开发的）功能的接口，接口必须是用于特定运行时互操作的（例如PInvoke）
然后驱动开发者按照非C++运行时规范，开发一套调用封装，所有Vapula功能通过互操作调用，然后Vapula核心会将适用于该运行时的组件的加载转交回给运行时去具体实现，这就是Vapula驱动的短路机制。

组件功能调用设计
组件功能通过Invoker、Worker配合，实现调用
Invoker由Library的对应Method的信息通过Driver构造
Invoker的Invoke方法是一整套适应Vapula设计的组件调用过程，包括组件调用前的栈准备、组件调用、异常保护、回滚支持以及调用后的栈维护操作。
用户通过Invoker的Invoke方法可以实现对功能的调用。
强烈建议使用Start、Pause、Resume、Restart、Stop等控制方法去调用并控制。
因为Vapula内部已经实现了一个优化的多核线程池，会按照机器硬件水平去维护一个线程池，然后调度所有的Invoker队列。由于该线程池控制了线程的数量，所以有效降低了应用程序的线程创建、销毁和调度时切换内核态的开销。
线程规模可以设置。

One worker for one process.

警告：不要把同一个Invoker多次注入工作器，这样会导致一个栈被多个线程竞争，导致不可预测的错误。工作器会检测希望注入的Invoker是否与运行中的某一个相同，这会严重影响效率，可以手工关闭该安全检查。

Runtime设计
Runtime是Vapula的主管理器对象，用于在运行期间维护这些对象：
1 驱动集合
2 切面集合
3 库集合
4 栈集合
5 编织机
6 工作者

加载vf_bridge库时，


Vapula发展目标
1.	支持虚拟线程以及线程池
2.	支持自定义类型扩展
3.	支持数据全端传输
4.	支持插件化组件模板（？）
5.	支持自动化测试
6.	支持智能（自动化）软件建模
7.	支持全端消息队列和事件
8.	云

Vapula调用功能的过程
调用方装载Vapula组件 => 调用方构造Vapula功能的执行器（此步骤会构造私有栈） => 调用方提供输入参数（根据需要） => 调用方通过执行器调用功能 => 调用方获取上下文并监听状态 => 调用方析构执行器（此步骤会销毁私有栈）

Vapula组件逻辑组成、物理组成、建模系统的关系
一个Vapula组件是一个动态链接库主体与其自身依赖
一个Vapula组件对应组件建模的图组
一个Vapula功能对应组件建模的图
一个Vapula组件包含若干功能
